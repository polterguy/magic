
/*
 * Authenticates the user with the specified [username] and [password] combination.
 * 
 * Notice, if [check-password] is false, we don't check the user's password, and
 * if [reset-password] is true, we generate a JWT token that can only be used to
 * change the user's password. The latter allows us to generated "change password links"
 * in the frontend, and similar type of logic.
 */
slots.create:magic.auth.authenticate

   /*
    * Checking if JWT secret has been changed, and
    * if not, simply checking if username/password is
    * root/root.
    */
   config.get:"magic:auth:secret"
   if
      or
         null:x:@config.get
         lt
            strings.length:x:@config.get
            .:int:50
      .lambda

         // System has not yet been setup.
         if
            and
               eq
                  get-value:x:@.arguments/*/username
                  .:root
               eq
                  get-value:x:@.arguments/*/password
                  .:root
            .lambda

               // Success!
               auth.ticket.create
                  username:root
                  roles
                     .:root
               unwrap:x:+/*
               return
                  ticket:x:@auth.ticket.create

         else

            // Failure!
            throw:Access denied
               status:int:401
               public:bool:true

   /*
    * If we came this far, the system has been setup,
    * and we can check the 'magic' database to see if
    * the credentials the caller provided is correct.
    */

   // Opens up our database connection.
   data.connect:magic

      // Selects the user with the given username from our table.
      .password
      .username
      data.read
         table:users
         columns
            username
            password
         where
            and
               username:x:@.arguments/*/username

      // Checking if user with specified [username] exists.
      if
         eq
            get-count:x:@data.read/*
            .:int:0
         .lambda

            // Checking if we can find the username through users_extra table.
            data.read
               table:users_extra
               columns
                  user
               where
                  and
                     type.eq:email
                     value.eq:x:@.arguments/*/username
            if
               exists:x:@data.read/*/*
               .lambda

                  // Looking up password now that we have the real username.
                  data.read
                     table:users
                     columns
                        username
                        password
                     where
                        and
                           username:x:@data.read/@data.read/*/*/user

                  // Checking if user with specified [username] exists.
                  if
                     not-exists:x:@data.read/*/*
                     .lambda

                        // No such user.
                        throw:Access denied
                           status:int:401
                           public:bool:true

                  else

                     // Storing password and username for later.
                     set-value:x:@.username
                        get-value:x:@data.read/*/*/username
                     set-value:x:@.password
                        get-value:x:@data.read/*/*/password

            else

               // No such user.
               throw:Access denied
                  status:int:401
                  public:bool:true

      else

         // Storing password and username for later.
         set-value:x:@.username
            get-value:x:@data.read/*/*/username
         set-value:x:@.password
            get-value:x:@data.read/*/*/password

      /*
       * This part exchanges the invocation to [crypto.password.verify] below,
       * but only if a configuration setting is found to be overriding the default
       * implementation from your "appsettings.json" file.
       */
      config.get:"magic:auth:authentication"
      if
         and
            neq:x:@config.get
               .
            neq:x:@config.get
               .:
            neq:x:@config.get
               .:crypto.password.verify
         .lambda

            /*
             * User has overridden the default password authentication slot invocation.
             * Hence we replace the existing invocation to [crypto.password.verify]
             * with the slot found from the "appsettings.json" file.
             * 
             * This is the part that basically allows for external username/password verifications.
             */
            strings.split:x:@config.get
               .:":"
            set-name:x:+/+/+/*/*
               get-value:x:@strings.split/0
            set-value:x:+/+/*/*
               get-value:x:@strings.split/1
            unwrap:x:+/*/*/*
            insert-after:x:@if/./**/crypto.password.verify
               .
                  foo
                     username:x:@.username
                     password:x:@.arguments/*/password
            remove-nodes:x:@if/./**/crypto.password.verify

      // Verify we have a password match.
      if
         crypto.password.verify:x:@.arguments/*/password
            hash:x:@.password
         .lambda

            // Now we need to select all roles user belongs to.
            data.read
               table:users_roles
               columns
                  role
               where
                  and
                     user:x:@.username

            // Then we can create our JWT token/ticket.
            add:x:+/*/roles
               get-nodes:x:@data.read/*/*
            auth.ticket.create
               username:x:@.username
               expires:x:@.arguments/*/expires
               roles

            // Logging the fact that user successfully logged in.
            log.info:User successfully authenticated
               username:x:@.username

            // Selecting all extra information associated with user.
            data.read
               table:users_extra
               columns
                  type
                  value
               where
                  and
                     user.eq:x:@.username
            for-each:x:@data.read/*
               set-name:x:./*/add/[0,1]/*/*/name
                  get-value:x:@.dp/#/*/type
               unwrap:x:+/*/*
               add:x:././*/return/*/extra
                  .
                     name:x:@.dp/#/*/value

            // Returning results back to caller.
            unwrap:x:+/+/*
            if
               not
                  exists:x:./././*/return/*/extra/0
               .lambda
                  remove-nodes:x:./././*/return/*/extra
            return
               ticket:x:@auth.ticket.create
               extra
      else

         // Hash version of password didn't match.
         throw:Access denied
            status:int:401
            public:bool:true
